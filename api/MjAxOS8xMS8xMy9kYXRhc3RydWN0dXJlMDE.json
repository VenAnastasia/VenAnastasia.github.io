{"title":"哈希表的构建与查找","date":"2019-11-13T10:33:05.000Z","date_formatted":{"ll":"2019年11月13日","L":"2019/11/13","MM-DD":"11-13"},"author":"Hard-working Anastasia","link":"2019/11/13/datastructure01","comments":true,"tags":["To be professional"],"categories":["Data Structure"],"updated":"2020-01-18T12:28:04.697Z","content":"<html><head></head><body><p>哈希表</p>\n<a id=\"more\"></a>\n\n<p>数据结构与算法（复习篇）<br>哈希表</p>\n<!--more-->\n\n<p><img src=\"https://s2.ax1x.com/2019/11/13/MYGpod.jpg\" alt=\"思维导图\" class=\"article-img\"></p>\n<h2 id=\"一、基本概念\"><a href=\"2019/11/13/datastructure01#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"1-哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系。哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将其放入此地址构成的表。\"><a href=\"2019/11/13/datastructure01#1-哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系。哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将其放入此地址构成的表。\" class=\"headerlink\" title=\"1. 哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系。哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将其放入此地址构成的表。\"></a>1. 哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系。哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将其放入此地址构成的表。</h3><h3 id=\"2-哈希查找（散列查找）：利用哈希函数进行查找的过程。\"><a href=\"2019/11/13/datastructure01#2-哈希查找（散列查找）：利用哈希函数进行查找的过程。\" class=\"headerlink\" title=\"2. 哈希查找（散列查找）：利用哈希函数进行查找的过程。\"></a>2. 哈希查找（散列查找）：利用哈希函数进行查找的过程。</h3><h3 id=\"3-冲突：对于不同的关键字ki、kj，若ki≠kj，但H-ki-H-kj-的现象叫冲突。\"><a href=\"2019/11/13/datastructure01#3-冲突：对于不同的关键字ki、kj，若ki≠kj，但H-ki-H-kj-的现象叫冲突。\" class=\"headerlink\" title=\"3. 冲突：对于不同的关键字ki、kj，若ki≠kj，但H(ki)=H(kj)的现象叫冲突。\"></a>3. 冲突：对于不同的关键字ki、kj，若ki≠kj，但H(ki)=H(kj)的现象叫冲突。</h3><h3 id=\"4-同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。\"><a href=\"2019/11/13/datastructure01#4-同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。\" class=\"headerlink\" title=\"4. 同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。\"></a>4. 同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。</h3><h2 id=\"二、哈希表的构造\"><a href=\"2019/11/13/datastructure01#二、哈希表的构造\" class=\"headerlink\" title=\"二、哈希表的构造\"></a>二、哈希表的构造</h2><h3 id=\"1-哈希表应包括：\"><a href=\"2019/11/13/datastructure01#1-哈希表应包括：\" class=\"headerlink\" title=\"1. 哈希表应包括：\"></a>1. 哈希表应包括：</h3><h4 id=\"1-哈希表的空间范围，即确定哈希函数的值域；\"><a href=\"2019/11/13/datastructure01#1-哈希表的空间范围，即确定哈希函数的值域；\" class=\"headerlink\" title=\"(1) 哈希表的空间范围，即确定哈希函数的值域；\"></a>(1) 哈希表的空间范围，即确定哈希函数的值域；</h4><h4 id=\"2-构造合适的哈希函数——使得对于所有可能的元素（记录的关键字），函数值均在哈希表的地址空间范围内，且出现冲突的可能最小。\"><a href=\"2019/11/13/datastructure01#2-构造合适的哈希函数——使得对于所有可能的元素（记录的关键字），函数值均在哈希表的地址空间范围内，且出现冲突的可能最小。\" class=\"headerlink\" title=\"(2) 构造合适的哈希函数——使得对于所有可能的元素（记录的关键字），函数值均在哈希表的地址空间范围内，且出现冲突的可能最小。\"></a>(2) 构造合适的哈希函数——使得对于所有可能的元素（记录的关键字），函数值均在哈希表的地址空间范围内，且出现冲突的可能最小。</h4><h4 id=\"3-处理冲突的方法。\"><a href=\"2019/11/13/datastructure01#3-处理冲突的方法。\" class=\"headerlink\" title=\"(3) 处理冲突的方法。\"></a>(3) 处理冲突的方法。</h4><h3 id=\"2-哈希函数的构造\"><a href=\"2019/11/13/datastructure01#2-哈希函数的构造\" class=\"headerlink\" title=\"2. 哈希函数的构造\"></a>2. 哈希函数的构造</h3><h4 id=\"1-“好坏”的主要评价因素有：-a-哈希函数构造简单；-b-能“均匀”地将散列表中的关键字映射到地址空间，所谓“均匀”是指发生冲突的可能性最小。\"><a href=\"2019/11/13/datastructure01#1-“好坏”的主要评价因素有：-a-哈希函数构造简单；-b-能“均匀”地将散列表中的关键字映射到地址空间，所谓“均匀”是指发生冲突的可能性最小。\" class=\"headerlink\" title=\"(1) “好坏”的主要评价因素有： a.哈希函数构造简单； b.能“均匀”地将散列表中的关键字映射到地址空间，所谓“均匀”是指发生冲突的可能性最小。\"></a>(1) “好坏”的主要评价因素有： a.哈希函数构造简单； b.能“均匀”地将散列表中的关键字映射到地址空间，所谓“均匀”是指发生冲突的可能性最小。</h4><h4 id=\"2-直接定址法\"><a href=\"2019/11/13/datastructure01#2-直接定址法\" class=\"headerlink\" title=\"(2) 直接定址法\"></a>(2) 直接定址法</h4><p>取关键字或关键字的某个线性函数作哈希地址，即H(key)=key 或者 H(key)=a*key+b (a,b为常数)</p>\n<h5 id=\"Tips：所得地址集合与关键字集合大小相等，不会发生冲突，但实际很少使用。\"><a href=\"2019/11/13/datastructure01#Tips：所得地址集合与关键字集合大小相等，不会发生冲突，但实际很少使用。\" class=\"headerlink\" title=\"Tips：所得地址集合与关键字集合大小相等，不会发生冲突，但实际很少使用。\"></a>Tips：所得地址集合与关键字集合大小相等，不会发生冲突，但实际很少使用。</h5><h4 id=\"3-数字分析法\"><a href=\"2019/11/13/datastructure01#3-数字分析法\" class=\"headerlink\" title=\"(3) 数字分析法\"></a>(3) 数字分析法</h4><p>对关键字进行分析，取关键字的若干位或组合作为哈希地址。</p>\n<h5 id=\"Tips：适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。\"><a href=\"2019/11/13/datastructure01#Tips：适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。\" class=\"headerlink\" title=\"Tips：适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。\"></a>Tips：适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况。</h5><p>Eg. 设有80个记录，关键字为8位十进制数，哈希地址为2位十进制数。</p>\n<h4 id=\"4-平方取中法\"><a href=\"2019/11/13/datastructure01#4-平方取中法\" class=\"headerlink\" title=\"(4) 平方取中法\"></a>(4) 平方取中法</h4><p>将关键字平方后取中间几位（由散列表的长度决定）作为哈希地址。<br>一个数平方后中间几位和数的每一位都有关，则由随机分布的关键字得到的散列地址也是随机的。</p>\n<h5 id=\"Tips：适用于不知道全部关键字的情况，较为常用。\"><a href=\"2019/11/13/datastructure01#Tips：适用于不知道全部关键字的情况，较为常用。\" class=\"headerlink\" title=\"Tips：适用于不知道全部关键字的情况，较为常用。\"></a>Tips：适用于不知道全部关键字的情况，较为常用。</h5><h4 id=\"5-折叠法\"><a href=\"2019/11/13/datastructure01#5-折叠法\" class=\"headerlink\" title=\"(5) 折叠法\"></a>(5) 折叠法</h4><p>将关键字分割成位数相同的几部分（最后一部分可以不同），然后取这几部分的叠加和作为哈希地址。<br>数位叠加有移位叠加（将分割后的几部分低位对齐相加）和间界叠加（从一端到另一端沿分割界来回折迭，然后对齐相加）两种。</p>\n<h5 id=\"Tips：适用于关键字位数很多，且每一位上数字分布大致均匀的情况。\"><a href=\"2019/11/13/datastructure01#Tips：适用于关键字位数很多，且每一位上数字分布大致均匀的情况。\" class=\"headerlink\" title=\"Tips：适用于关键字位数很多，且每一位上数字分布大致均匀的情况。\"></a>Tips：适用于关键字位数很多，且每一位上数字分布大致均匀的情况。</h5><h4 id=\"6-除留余数法🔔\"><a href=\"2019/11/13/datastructure01#6-除留余数法🔔\" class=\"headerlink\" title=\"(6) 除留余数法🔔\"></a>(6) 除留余数法🔔</h4><p>取关键字被某个不大于哈希表表长m的数p除后所得的余数作为哈希地址，即H(key)=key MOD p (p≤m)<br>⭐p的选取：<br>a. 选取p=(2的i次方)(p<=m):运算便于用移位来实现，但等于将关键字的高位忽略而仅留下低位二进制数。高位不同而低位相同的关键字是同义词。<br>b. 选取p=q*f(q、f都是质因数，p≤m)：则所有含有q或者f因子的关键字的散列地址均是q或者f的倍数。<br>c. 📙选取p为素数或p=q*f(q、f是质数且均大于20，p<=m)：常用的选取方法，能减少冲突出现的可能性。</p>\n<h5 id=\"Tips：简单、常用\"><a href=\"2019/11/13/datastructure01#Tips：简单、常用\" class=\"headerlink\" title=\"Tips：简单、常用\"></a>Tips：简单、常用</h5><h4 id=\"7-随机数法\"><a href=\"2019/11/13/datastructure01#7-随机数法\" class=\"headerlink\" title=\"(7) 随机数法\"></a>(7) 随机数法</h4><p>取关键字的随机函数值作为哈希地址，即H(key)=random(key)</p>\n<h5 id=\"Tips：适用于散列表中关键字长度不等的情况。\"><a href=\"2019/11/13/datastructure01#Tips：适用于散列表中关键字长度不等的情况。\" class=\"headerlink\" title=\"Tips：适用于散列表中关键字长度不等的情况。\"></a>Tips：适用于散列表中关键字长度不等的情况。</h5><h3 id=\"3-选取哈希函数需考虑的因素\"><a href=\"2019/11/13/datastructure01#3-选取哈希函数需考虑的因素\" class=\"headerlink\" title=\"3. 选取哈希函数需考虑的因素\"></a>3. 选取哈希函数需考虑的因素</h3><h4 id=\"1-计算哈希函数所需时间；\"><a href=\"2019/11/13/datastructure01#1-计算哈希函数所需时间；\" class=\"headerlink\" title=\"(1) 计算哈希函数所需时间；\"></a>(1) 计算哈希函数所需时间；</h4><h4 id=\"2-关键字的长度；\"><a href=\"2019/11/13/datastructure01#2-关键字的长度；\" class=\"headerlink\" title=\"(2) 关键字的长度；\"></a>(2) 关键字的长度；</h4><h4 id=\"3-哈希表的长度（哈希地址范围）；\"><a href=\"2019/11/13/datastructure01#3-哈希表的长度（哈希地址范围）；\" class=\"headerlink\" title=\"(3) 哈希表的长度（哈希地址范围）；\"></a>(3) 哈希表的长度（哈希地址范围）；</h4><h4 id=\"4-关键字分布情况；\"><a href=\"2019/11/13/datastructure01#4-关键字分布情况；\" class=\"headerlink\" title=\"(4) 关键字分布情况；\"></a>(4) 关键字分布情况；</h4><h4 id=\"5-记录的查找频率。\"><a href=\"2019/11/13/datastructure01#5-记录的查找频率。\" class=\"headerlink\" title=\"(5) 记录的查找频率。\"></a>(5) 记录的查找频率。</h4><h2 id=\"三、处理冲突的办法\"><a href=\"2019/11/13/datastructure01#三、处理冲突的办法\" class=\"headerlink\" title=\"三、处理冲突的办法\"></a>三、处理冲突的办法</h2><h3 id=\"冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。\"><a href=\"2019/11/13/datastructure01#冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。\" class=\"headerlink\" title=\"冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。\"></a>冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。</h3><h3 id=\"1-开放定址法\"><a href=\"2019/11/13/datastructure01#1-开放定址法\" class=\"headerlink\" title=\"1. 开放定址法\"></a>1. 开放定址法</h3><h4 id=\"当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址（开放的地址）为止，将发生冲突的记录放到该地址中。散列表的计算公式是：\"><a href=\"2019/11/13/datastructure01#当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址（开放的地址）为止，将发生冲突的记录放到该地址中。散列表的计算公式是：\" class=\"headerlink\" title=\"当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址（开放的地址）为止，将发生冲突的记录放到该地址中。散列表的计算公式是：\"></a>当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址（开放的地址）为止，将发生冲突的记录放到该地址中。散列表的计算公式是：</h4><p>Hi(key)= (H(key)+di) MOD m, i=(……)<br>di：第i次探测时的增量序列；<br>Hi(key)：经第i次探测后得到的散列地址。</p>\n<h5 id=\"1-线性探测法\"><a href=\"2019/11/13/datastructure01#1-线性探测法\" class=\"headerlink\" title=\"(1) 线性探测法\"></a>(1) 线性探测法</h5><h5 id=\"增量序列为：di-1-2-3-……-m-1\"><a href=\"2019/11/13/datastructure01#增量序列为：di-1-2-3-……-m-1\" class=\"headerlink\" title=\"增量序列为：di=1,2,3,……,m-1\"></a>增量序列为：di=1,2,3,……,m-1</h5><h5 id=\"Tips：优点：只要散列表未满，总能找到一个不冲突的散列地址；缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而增加了更多的冲突机会（这种现象称为冲突的“聚集”）。\"><a href=\"2019/11/13/datastructure01#Tips：优点：只要散列表未满，总能找到一个不冲突的散列地址；缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而增加了更多的冲突机会（这种现象称为冲突的“聚集”）。\" class=\"headerlink\" title=\"Tips：优点：只要散列表未满，总能找到一个不冲突的散列地址；缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而增加了更多的冲突机会（这种现象称为冲突的“聚集”）。\"></a>Tips：优点：只要散列表未满，总能找到一个不冲突的散列地址；缺点：每个产生冲突的记录被散列到离冲突最近的空地址上，从而增加了更多的冲突机会（这种现象称为冲突的“聚集”）。</h5><h5 id=\"2-二次探测法\"><a href=\"2019/11/13/datastructure01#2-二次探测法\" class=\"headerlink\" title=\"(2) 二次探测法\"></a>(2) 二次探测法</h5><h5 id=\"增量序列为：di-1²，-1²，2²，-2²，……，±k²-k≤-m-2\"><a href=\"2019/11/13/datastructure01#增量序列为：di-1²，-1²，2²，-2²，……，±k²-k≤-m-2\" class=\"headerlink\" title=\"增量序列为：di=1²，-1²，2²，-2²，……，±k² (k≤[m/2])\"></a>增量序列为：di=1²，-1²，2²，-2²，……，±k² (k≤[m/2])</h5><h5 id=\"Tips：优点：探测序列跳跃式地分布到整个表中，不易产生冲突的“聚集”现象；缺点：不能保证探测到散列表的所有地址。\"><a href=\"2019/11/13/datastructure01#Tips：优点：探测序列跳跃式地分布到整个表中，不易产生冲突的“聚集”现象；缺点：不能保证探测到散列表的所有地址。\" class=\"headerlink\" title=\"Tips：优点：探测序列跳跃式地分布到整个表中，不易产生冲突的“聚集”现象；缺点：不能保证探测到散列表的所有地址。\"></a>Tips：优点：探测序列跳跃式地分布到整个表中，不易产生冲突的“聚集”现象；缺点：不能保证探测到散列表的所有地址。</h5><h5 id=\"3-伪随机探测法\"><a href=\"2019/11/13/datastructure01#3-伪随机探测法\" class=\"headerlink\" title=\"(3) 伪随机探测法\"></a>(3) 伪随机探测法</h5><h5 id=\"增量序列：使用一个伪随机函数来产生一个落在闭区间-1-m-1-的随机序列。\"><a href=\"2019/11/13/datastructure01#增量序列：使用一个伪随机函数来产生一个落在闭区间-1-m-1-的随机序列。\" class=\"headerlink\" title=\"增量序列：使用一个伪随机函数来产生一个落在闭区间[1,m-1]的随机序列。\"></a>增量序列：使用一个伪随机函数来产生一个落在闭区间[1,m-1]的随机序列。</h5><h3 id=\"2-再哈希法\"><a href=\"2019/11/13/datastructure01#2-再哈希法\" class=\"headerlink\" title=\"2. 再哈希法\"></a>2. 再哈希法</h3><h4 id=\"构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即Hi-RHi-key-i-1-2-…-k\"><a href=\"2019/11/13/datastructure01#构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即Hi-RHi-key-i-1-2-…-k\" class=\"headerlink\" title=\"构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即Hi=RHi(key)  i=1,2,…,k\"></a>构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即Hi=RHi(key)  i=1,2,…,k</h4><h5 id=\"Tips-优点：不易产生冲突的“聚集”现象；缺点：计算时间增加。\"><a href=\"2019/11/13/datastructure01#Tips-优点：不易产生冲突的“聚集”现象；缺点：计算时间增加。\" class=\"headerlink\" title=\"Tips: 优点：不易产生冲突的“聚集”现象；缺点：计算时间增加。\"></a>Tips: 优点：不易产生冲突的“聚集”现象；缺点：计算时间增加。</h5><h3 id=\"3-链地址法\"><a href=\"2019/11/13/datastructure01#3-链地址法\" class=\"headerlink\" title=\"3. 链地址法\"></a>3. 链地址法</h3><h4 id=\"将所有关键字为同义词（散列地址相同）的记录存储在一单链表中，并用一维数组存放链表的头指针-RecNode-linkhash-m-，其中RecNode是结点类型，每个分量的初值为空。\"><a href=\"2019/11/13/datastructure01#将所有关键字为同义词（散列地址相同）的记录存储在一单链表中，并用一维数组存放链表的头指针-RecNode-linkhash-m-，其中RecNode是结点类型，每个分量的初值为空。\" class=\"headerlink\" title=\"将所有关键字为同义词（散列地址相同）的记录存储在一单链表中，并用一维数组存放链表的头指针 RecNode *linkhash[m] ，其中RecNode是结点类型，每个分量的初值为空。\"></a>将所有关键字为同义词（散列地址相同）的记录存储在一单链表中，并用一维数组存放链表的头指针 RecNode *linkhash[m] ，其中RecNode是结点类型，每个分量的初值为空。</h4><h5 id=\"Tips-优点：不易产生冲突的“聚集”；删除记录也简单。\"><a href=\"2019/11/13/datastructure01#Tips-优点：不易产生冲突的“聚集”；删除记录也简单。\" class=\"headerlink\" title=\"Tips: 优点：不易产生冲突的“聚集”；删除记录也简单。\"></a>Tips: 优点：不易产生冲突的“聚集”；删除记录也简单。</h5><h3 id=\"4-建立公共溢出区\"><a href=\"2019/11/13/datastructure01#4-建立公共溢出区\" class=\"headerlink\" title=\"4. 建立公共溢出区\"></a>4. 建立公共溢出区</h3><h4 id=\"在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。设基本散列表为hashtable-m-，每个分量保存一个记录；溢出表overtable-m-，一旦某个记录的散列地址发生冲突，都填入溢出表中。\"><a href=\"2019/11/13/datastructure01#在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。设基本散列表为hashtable-m-，每个分量保存一个记录；溢出表overtable-m-，一旦某个记录的散列地址发生冲突，都填入溢出表中。\" class=\"headerlink\" title=\"在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。设基本散列表为hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。\"></a>在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。设基本散列表为hashtable[m]，每个分量保存一个记录；溢出表overtable[m]，一旦某个记录的散列地址发生冲突，都填入溢出表中。</h4><h2 id=\"四、哈希查找与分析\"><a href=\"2019/11/13/datastructure01#四、哈希查找与分析\" class=\"headerlink\" title=\"四、哈希查找与分析\"></a>四、哈希查找与分析</h2><h3 id=\"1-哈希查找过程\"><a href=\"2019/11/13/datastructure01#1-哈希查找过程\" class=\"headerlink\" title=\"1. 哈希查找过程\"></a>1. 哈希查找过程</h3><iframe src=\"https://s2.ax1x.com/2019/11/13/MYVkHf.png\" width=\"100%\" height=\"300\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n<h3 id=\"2-哈希查找分析\"><a href=\"2019/11/13/datastructure01#2-哈希查找分析\" class=\"headerlink\" title=\"2.哈希查找分析\"></a>2.哈希查找分析</h3><h4 id=\"由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用到ASL。\"><a href=\"2019/11/13/datastructure01#由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用到ASL。\" class=\"headerlink\" title=\"由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用到ASL。\"></a>由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用到ASL。</h4><h4 id=\"比较次数取决于：\"><a href=\"2019/11/13/datastructure01#比较次数取决于：\" class=\"headerlink\" title=\"比较次数取决于：\"></a>比较次数取决于：</h4><h5 id=\"1-哈希函数；\"><a href=\"2019/11/13/datastructure01#1-哈希函数；\" class=\"headerlink\" title=\"(1) 哈希函数；\"></a>(1) 哈希函数；</h5><h5 id=\"2-处理冲突的方法；\"><a href=\"2019/11/13/datastructure01#2-处理冲突的方法；\" class=\"headerlink\" title=\"(2) 处理冲突的方法；\"></a>(2) 处理冲突的方法；</h5><h5 id=\"3-哈希表的装填因子α。α-表中填入的记录数-哈希表的长度。α越小，发生冲突的可能性越小。\"><a href=\"2019/11/13/datastructure01#3-哈希表的装填因子α。α-表中填入的记录数-哈希表的长度。α越小，发生冲突的可能性越小。\" class=\"headerlink\" title=\"(3) 哈希表的装填因子α。α=表中填入的记录数/哈希表的长度。α越小，发生冲突的可能性越小。\"></a>(3) 哈希表的装填因子α。α=表中填入的记录数/哈希表的长度。α越小，发生冲突的可能性越小。</h5></body></html>","prev":{"title":"Array & String","link":"2019/11/14/for-competition02"},"next":{"title":"Sentence Patterns 04","link":"2019/11/12/sentence04"},"plink":"https://VenAnastasia.github.io/2019/11/13/datastructure01/","toc":[{"title":"","id":"一、基本概念","index":"1","children":[{"title":"","id":"1-哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系。哈希表：应用哈希函数，由记录的关键字确定记录在表中的地址，并将其放入此地址构成的表。","index":"1.1"},{"title":"","id":"2-哈希查找（散列查找）：利用哈希函数进行查找的过程。","index":"1.2"},{"title":"","id":"3-冲突：对于不同的关键字ki、kj，若ki≠kj，但H-ki-H-kj-的现象叫冲突。","index":"1.3"},{"title":"","id":"4-同义词：具有相同函数值的两个不同的关键字，称为该哈希函数的同义词。","index":"1.4"}]},{"title":"","id":"二、哈希表的构造","index":"2","children":[{"title":"","id":"1-哈希表应包括：","index":"2.1","children":[{"title":"","id":"1-哈希表的空间范围，即确定哈希函数的值域；","index":"2.1.1"},{"title":"","id":"2-构造合适的哈希函数——使得对于所有可能的元素（记录的关键字），函数值均在哈希表的地址空间范围内，且出现冲突的可能最小。","index":"2.1.2"},{"title":"","id":"3-处理冲突的方法。","index":"2.1.3"}]},{"title":"","id":"2-哈希函数的构造","index":"2.2","children":[{"title":"","id":"1-“好坏”的主要评价因素有：-a-哈希函数构造简单；-b-能“均匀”地将散列表中的关键字映射到地址空间，所谓“均匀”是指发生冲突的可能性最小。","index":"2.2.1"},{"title":"","id":"2-直接定址法","index":"2.2.2"},{"title":"","id":"3-数字分析法","index":"2.2.3"},{"title":"","id":"4-平方取中法","index":"2.2.4"},{"title":"","id":"5-折叠法","index":"2.2.5"},{"title":"","id":"6-除留余数法🔔","index":"2.2.6"},{"title":"","id":"7-随机数法","index":"2.2.7"}]},{"title":"","id":"3-选取哈希函数需考虑的因素","index":"2.3","children":[{"title":"","id":"1-计算哈希函数所需时间；","index":"2.3.1"},{"title":"","id":"2-关键字的长度；","index":"2.3.2"},{"title":"","id":"3-哈希表的长度（哈希地址范围）；","index":"2.3.3"},{"title":"","id":"4-关键字分布情况；","index":"2.3.4"},{"title":"","id":"5-记录的查找频率。","index":"2.3.5"}]}]},{"title":"","id":"三、处理冲突的办法","index":"3","children":[{"title":"","id":"冲突处理：当出现冲突时，为冲突元素找到另一个存储位置。","index":"3.1"},{"title":"","id":"1-开放定址法","index":"3.2","children":[{"title":"","id":"当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址（开放的地址）为止，将发生冲突的记录放到该地址中。散列表的计算公式是：","index":"3.2.1"}]},{"title":"","id":"2-再哈希法","index":"3.3","children":[{"title":"","id":"构造若干个哈希函数，当发生冲突时，利用不同的哈希函数再计算下一个新哈希地址，直到不发生冲突为止。即Hi-RHi-key-i-1-2-…-k","index":"3.3.1"}]},{"title":"","id":"3-链地址法","index":"3.4","children":[{"title":"","id":"将所有关键字为同义词（散列地址相同）的记录存储在一单链表中，并用一维数组存放链表的头指针-RecNode-linkhash-m-，其中RecNode是结点类型，每个分量的初值为空。","index":"3.4.1"}]},{"title":"","id":"4-建立公共溢出区","index":"3.5","children":[{"title":"","id":"在基本散列表之外，另外设立一个溢出表保存与基本表中记录冲突的所有记录。设基本散列表为hashtable-m-，每个分量保存一个记录；溢出表overtable-m-，一旦某个记录的散列地址发生冲突，都填入溢出表中。","index":"3.5.1"}]}]},{"title":"","id":"四、哈希查找与分析","index":"4","children":[{"title":"","id":"1-哈希查找过程","index":"4.1"},{"title":"","id":"2-哈希查找分析","index":"4.2","children":[{"title":"","id":"由于“冲突”，查找过程仍是一个给定值与关键字进行比较的过程，评价哈希查找效率仍要用到ASL。","index":"4.2.1"},{"title":"","id":"比较次数取决于：","index":"4.2.2"}]}]}],"reward":true,"copyright":{"author":"Hard-working Anastasia","license":"No permission to reproduce. Anastasia only.😎","updated":"2020年1月18日"}}